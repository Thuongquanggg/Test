

// üÖæÔ∏è T√™n file: Slow V2 (js) - Phi√™n b·∫£n c·∫£i ti·∫øn
import http from 'k6/http';
import { check, group, sleep, fail } from 'k6';
import { html } from 'k6/html';

// --- C·∫§U H√åNH ---
const BASE_URL = __ENV.TARGET_URL || 'https://certapple.com';
const PROXY_FILE_URL = 'https://raw.githubusercontent.com/Thuongquanggg/Proxy/main/proxies.txt';
const PROXY_CHECK_URL = 'https://api.ipify.org';
const MAX_PROXIES_TO_USE = 200;
const PROXY_CHECK_TIMEOUT = '7s';
const MAX_FETCH_ATTEMPTS = 3;
const PROXY_REFRESH_INTERVAL = 180; // Gi√¢y (3 ph√∫t)

// --- BI·∫æN TO√ÄN C·ª§C ---
const USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/115.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/114.0.1823.51',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (Linux; Android 13; SM-S908U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36'
];

// Bi·∫øn proxyPool ƒë∆∞·ª£c chia s·∫ª gi·ªØa c√°c VUs v√† c√°c scenarios.
let proxyPool = [];

// H√†m l·∫•y v√† x√°c th·ª±c proxy (gi·ªØ nguy√™n, ƒë√£ r·∫•t t·ªët)
function fetchAndValidateProxies() {
    let allProxies = [];
    for (let attempt = 1; attempt <= MAX_FETCH_ATTEMPTS; attempt++) {
        const res = http.get(PROXY_FILE_URL, { timeout: '30s' });
        if (res.status === 200 && res.body) {
            allProxies = res.body.trim().split('\n').filter(p => p.trim() !== '');
            if (allProxies.length > 0) break;
        }
        if (attempt < MAX_FETCH_ATTEMPTS) sleep(2);
    }
    if (allProxies.length === 0) {
        console.warn("Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch proxy th√¥ t·ª´ GitHub.");
        return [];
    }

    const proxiesToCheck = allProxies.slice(0, MAX_PROXIES_TO_USE);
    
    const requests = {};
    proxiesToCheck.forEach(p => {
        requests[p] = { method: 'GET', url: PROXY_CHECK_URL, params: { proxy: p, timeout: PROXY_CHECK_TIMEOUT } };
    });
    const responses = http.batch(requests);
    const liveProxies = [];
    for (const proxy in responses) {
        if (responses[proxy].status === 200) {
            liveProxies.push(proxy);
        }
    }

    console.log(`Ki·ªÉm tra ho√†n t·∫•t: ${liveProxies.length}/${proxiesToCheck.length} proxy c√≤n s·ªëng.`);
    return liveProxies;
}

// --- H√ÄM CHU·∫®N B·ªä (SETUP FUNCTION) ---
export function setup() {
    console.log("--- GIAI ƒêO·∫†N SETUP: Chu·∫©n b·ªã proxy ban ƒë·∫ßu ---");
    const initialProxies = fetchAndValidateProxies();

    if (initialProxies.length === 0) {
        fail("Kh√¥ng th·ªÉ l·∫•y danh s√°ch proxy ban ƒë·∫ßu. D·ª´ng b√†i test.");
    }

    proxyPool = initialProxies;
    console.log(`--- GIAI ƒêO·∫†N SETUP: Ho√†n t·∫•t. S·∫µn s√†ng ${proxyPool.length} proxy. ---`);
    return { initialProxyCount: proxyPool.length };
}

// --- C·∫§U H√åNH K·ªäCH B·∫¢N TEST (ƒê√É C·∫¢I TI·∫æN) ---
export const options = {
    insecureSkipTLSVerify: true,
    scenarios: {
        // K·ªãch b·∫£n ch√≠nh: M√¥ ph·ªèng l∆∞u l∆∞·ª£ng truy c·∫≠p
        daily_traffic_simulation: {
            executor: 'ramping-vus',
            startTime: '0s',
            stages: [
                { duration: '2s', target: 2000 },
                { duration: '2s', target: 2000 },
                { duration: '2s', target: 2000 },
                { duration: '30s', target: 2000 },
                { duration: '1m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '2m', target: 2000 },
                { duration: '6000m', target: 2000 },
            ],
            gracefulStop: '2m',
            exec: 'main', // H√†m th·ª±c thi ch√≠nh c·ªßa k·ªãch b·∫£n n√†y
        },
        // K·ªãch b·∫£n ph·ª•: Ch·∫°y n·ªÅn ƒë·ªÉ c·∫≠p nh·∫≠t proxy m·ªôt c√°ch an to√†n
        proxy_updater: {
            executor: 'per-vu-iterations',
            vus: 1, // Ch·ªâ 1 VU duy nh·∫•t ƒë·ªÉ tr√°nh race condition
            iterations: 999999, // Ch·∫°y l·∫∑p l·∫°i li√™n t·ª•c
            maxDuration: '6001m', // Ch·∫°y trong su·ªët th·ªùi gian test
            exec: 'proxyUpdater', // H√†m th·ª±c thi c·ªßa k·ªãch b·∫£n n√†y
            startTime: '10s', // B·∫Øt ƒë·∫ßu sau k·ªãch b·∫£n ch√≠nh m·ªôt ch√∫t
        },
    },
    thresholds: {
        'http_req_duration{type:html}': ['p(95)<5000'],
        'http_req_duration{type:asset}': ['p(95)<3000'],
        'http_req_failed': ['rate<0.30'],
        'checks': ['rate>0.70'],
    },
};

// --- H√ÄM C·∫¨P NH·∫¨T PROXY (D√ÄNH CHO SCENARIO RI√äNG) ---
export function proxyUpdater() {
    // Ch·ªù ƒë·∫øn l·∫ßn c·∫≠p nh·∫≠t ti·∫øp theo
    sleep(PROXY_REFRESH_INTERVAL);

    console.log(`[ProxyUpdaterVU] B·∫Øt ƒë·∫ßu l√†m m·ªõi danh s√°ch proxy...`);
    const newProxies = fetchAndValidateProxies();
    
    if (newProxies.length > 0) {
        console.log(`[ProxyUpdaterVU] C·∫≠p nh·∫≠t th√†nh c√¥ng ${newProxies.length} proxy m·ªõi.`);
        proxyPool = newProxies; 
    } else {
        console.warn(`[ProxyUpdaterVU] Kh√¥ng l·∫•y ƒë∆∞·ª£c proxy m·ªõi. Ti·∫øp t·ª•c s·ª≠ d·ª•ng danh s√°ch c≈© (${proxyPool.length} proxy).`);
    }
}

// --- ƒêI·ªÇM V√ÄO CH√çNH (MAIN VU FUNCTION - ƒê√É ƒê∆†N GI·∫¢N H√ìA) ---
export function main() {
    // N·∫øu b·ªÉ proxy v√¨ l√Ω do n√†o ƒë√≥ b·ªã r·ªóng, ch·ªù m·ªôt ch√∫t ƒë·ªÉ VU c·∫≠p nh·∫≠t c√≥ th·ªùi gian ch·∫°y
    if (proxyPool.length === 0) {
        console.log(`[VU=${__VU}] B·ªÉ proxy r·ªóng, ƒëang ch·ªù proxy ƒë∆∞·ª£c c·∫≠p nh·∫≠t...`);
        sleep(5); // Ch·ªù 5 gi√¢y r·ªìi th·ª≠ l·∫°i ·ªü v√≤ng l·∫∑p ti·∫øp theo
        return;
    }

    // Logic m√¥ ph·ªèng h√†nh vi ng∆∞·ªùi d√πng
    const random = Math.random();
    if (random < 0.2) {
        firstTimeVisitor();
    } else if (random < 0.4) {
        returningVisitor();
    } else {
        chaoticBrowser();
    }
}

// --- C√ÅC H√ÄM M√î PH·ªéNG H√ÄNH VI ---
// Kh√¥ng c·∫ßn truy·ªÅn `proxies` v√†o n·ªØa v√¨ n√≥ l√† bi·∫øn to√†n c·ª•c
function firstTimeVisitor() {
    const params = getBaseParams();
    group('H√†nh vi: Kh√°ch l·∫ßn ƒë·∫ßu', function () {
        const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
        const isStatusOk = check(res, { 'Trang ch·ªß OK': (r) => r && r.status === 200 });
        if (isStatusOk && res.body) {
            loadPageAssets(res, params, null);
        }
    });
    sleep(Math.random() * 4 + 3);
}

const vuCache = new Map();

function returningVisitor() {
    const params = getBaseParams();
    group('H√†nh vi: Kh√°ch quay l·∫°i', function () {
        const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
        const isStatusOk = check(res, { 'Trang ch·ªß OK': (r) => r && r.status === 200 });
        if (isStatusOk && res.body) {
            loadPageAssets(res, params, vuCache);
        }
    });
    sleep(Math.random() * 4 + 3);
}

const internalLinks = new Set([BASE_URL]);

function chaoticBrowser() {
    const params = getBaseParams();
    group('H√†nh vi: Ng∆∞·ªùi d√πng ƒëi d·∫°o', function () {
        const linksArray = Array.from(internalLinks);
        const currentUrl = linksArray.length > 0 ? linksArray[Math.floor(Math.random() * linksArray.length)] : BASE_URL;
        const res = http.get(currentUrl, { ...params, tags: { type: 'html' } });
        const isStatusOk = check(res, { 'T·∫£i trang OK': (r) => r && r.status === 200 });
        if (isStatusOk && res.body) {
            const discoveredLinks = loadPageAssets(res, params, null);
            discoveredLinks.forEach(link => internalLinks.add(link));
        }
    });
    sleep(Math.random() * 5 + 4);
}

// --- C√ÅC H√ÄM H·ªñ TR·ª¢ ---
function getBaseParams() {
    const params = {
        headers: {
            'User-Agent': USER_AGENTS[__VU % USER_AGENTS.length],
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
        },
    };

    if (proxyPool && proxyPool.length > 0) {
        // C·∫£i ti·∫øn: Ch·ªçn proxy ng·∫´u nhi√™n ƒë·ªÉ ph√¢n ph·ªëi t·∫£i ƒë·ªÅu h∆°n
        params.proxy = proxyPool[Math.floor(Math.random() * proxyPool.length)];
    } else {
        // D√≤ng n√†y gi·ªù √≠t kh·∫£ nƒÉng x·∫£y ra h∆°n do c√≥ check ·ªü ƒë·∫ßu h√†m main
        console.warn(`[VU=${__VU}] B·ªÉ proxy r·ªóng. Request s·∫Ω ƒë∆∞·ª£c g·ª≠i kh√¥ng qua proxy.`);
    }
    return params;
}

// H√†m loadPageAssets v√† resolveUrl gi·ªØ nguy√™n nh∆∞ ban ƒë·∫ßu
function loadPageAssets(res, params, cache) {
    const discoveredLinks = new Set();
    if (!res || !res.body) {
        // console.error(`Ph·∫£n h·ªìi kh√¥ng h·ª£p l·ªá: ${JSON.stringify(res)}`);
        return Array.from(discoveredLinks);
    }
    
    const doc = html.parse(res.body);
    const assetUrls = new Set();
    
    doc.find('link[href], script[src], img[src], video[src], audio[src], source[src]').each((_, el) => {
        const url = el.attr('href') || el.attr('src');
        if (url) assetUrls.add(resolveUrl(url, res.url));
    });

    const contentType = res.headers['Content-Type'];
    const isCssResponse = contentType && contentType.includes('css');
    const cssBody = doc.find('style').text() + (isCssResponse ? res.body : '');
    const cssUrls = cssBody.match(/url\(['"]?([^'")]+)['"]?\)/g) || [];
    cssUrls.forEach(match => {
        const url = match.replace(/url\(['"]?/, '').replace(/['"]?\)/, '');
        if (url && !url.startsWith('data:')) {
            assetUrls.add(resolveUrl(url, res.url));
        }
    });

    doc.find('a[href]').each((_, el) => {
        const link = el.attr('href');
        if (link) {
            const resolvedLink = resolveUrl(link, res.url);
            if (resolvedLink && resolvedLink.startsWith(BASE_URL) && !resolvedLink.match(/\.(jpg|jpeg|png|gif|css|js|pdf)$/i) && !resolvedLink.includes('#')) {
                discoveredLinks.add(resolvedLink);
            }
        }
    });

    const requests = [];
    assetUrls.forEach(url => {
        if (url) {
            const assetParams = { ...params, tags: { type: 'asset' } };
            if (cache && cache.has(url)) {
                assetParams.headers['If-None-Match'] = cache.get(url);
            }
            requests.push(['GET', url, null, assetParams]);
        }
    });

    if (requests.length > 0) {
        const responses = http.batch(requests);
        if (cache) {
            responses.forEach((r, i) => {
                const url = requests[i][1];
                if (r && r.status === 200 && r.headers['Etag']) {
                    cache.set(url, r.headers['Etag']);
                }
                if (r) {
                    check(r, { 'T√†i nguy√™n cache h·ª£p l·ªá (200 ho·∫∑c 304)': (res) => [200, 304].includes(res.status) });
                }
            });
        }
    }
    return Array.from(discoveredLinks);
}

function resolveUrl(url, pageUrl) {
    try {
        return (new URL(url, pageUrl)).href;
    } catch (e) {
        // console.warn(`URL kh√¥ng h·ª£p l·ªá: "${url}" tr√™n trang ${pageUrl}`);
        return '';
    }
}
