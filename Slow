// 🅾️ Tên file: Slow_fixed.js
// Phiên bản đã sửa lỗi logic và tối ưu hóa

import http from 'k6/http';
import { check, group, sleep } from 'k6';
import { html } from 'k6/html';

// --- CẤU HÌNH ---
const BASE_URL = __ENV.TARGET_URL || 'https://certapple.com';
const PROXY_FILE_URL = 'https://raw.githubusercontent.com/Thuongquanggg/Proxy/main/proxies.txt';

// --- BIẾN TOÀN CỤC ---
const USER_AGENTS = [
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/115.0',
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/114.0.1823.51',
'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1',
'Mozilla/5.0 (Linux; Android 13; SM-S908U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36'
];

// --- CÁC HÀM LIÊN QUAN ĐẾN PROXY ---
// Hàm này chỉ nên được gọi từ setup() để tránh tình trạng "thundering herd"
function fetchProxies() {
console.log('Đang lấy danh sách proxy từ GitHub...');
const res = http.get(PROXY_FILE_URL, { timeout: '30s' });
if (res.status === 200 && res.body) {
const allNewProxies = res.body.trim().split('\n').filter(p => p.trim() !== '');
if (allNewProxies.length > 0) {
const newProxies = allNewProxies.slice(0, 100); // Giới hạn 100 proxy
console.log(`Lấy thành công ${newProxies.length} proxy.`);
return newProxies;
} else {
console.warn('File proxy.txt trên GitHub rỗng hoặc không có proxy hợp lệ.');
}
} else {
console.error(`Không thể lấy proxy từ GitHub. Status: ${res.status}`);
}
return []; // Trả về mảng rỗng nếu thất bại
}

// --- CẤU HÌNH KỊCH BẢN TEST ---
export const options = {
insecureSkipTLSVerify: true,
scenarios: {
daily_traffic_simulation: {
executor: 'ramping-vus',
startTime: '0s',
// SỬA LẠI STAGES HỢP LÝ HƠN: Tăng tải từ từ, giữ ổn định, và giảm tải
stages: [
{ duration: '10s', target: 500 },  
{ duration: '20', target: 1000 },  
{ duration: '1m', target: 2000 }, 
{ duration: '10m', target: 2000 },
{ duration: '2m', target: 2000 },   
{ duration: '2m', target: 2000 },  
{ duration: '5m', target: 2000 },  
{ duration: '2m', target: 2000 }, 
{ duration: '6000m', target: 2000 },

],
gracefulStop: '2m',
exec: 'runTest', // Đặt tên cho hàm thực thi chính để rõ ràng
},
},
thresholds: {
'http_req_duration{type:html}': ['p(95)<5000'],
'http_req_duration{type:asset}': ['p(95)<3000'],
'http_req_failed': ['rate<0.30'],
'checks': ['rate>0.70'],
},
};

// --- SETUP FUNCTION ---
// Chạy 1 lần duy nhất trước khi các VUs bắt đầu. Lý tưởng để lấy dữ liệu dùng chung.
export function setup() {
console.log('--- Bắt đầu pha SETUP ---');
const initialProxies = fetchProxies();
if (initialProxies.length === 0) {
// Nếu không lấy được proxy, kịch bản sẽ vô nghĩa. Dừng test tại đây.
throw new Error('Không thể lấy danh sách proxy ban đầu. Dừng kịch bản.');
}
console.log(`--- SETUP hoàn tất, lấy được ${initialProxies.length} proxy ---`);
// Dữ liệu trả về từ setup sẽ được truyền vào hàm thực thi chính của mỗi VU
return { proxies: initialProxies };
}

// --- ĐIỂM VÀO CHÍNH (MAIN VU FUNCTION) ---
// Tên hàm khớp với 'exec' trong options.
// 'data' là đối tượng được trả về từ hàm setup().
export function runTest(data) {
// Mỗi VU sẽ nhận được cùng một danh sách proxy từ 'data'
const proxyPool = data.proxies;

// Logic chọn hành vi người dùng
const random = Math.random();
if (random < 0.2) {
firstTimeVisitor(proxyPool);
} else if (random < 0.4) {
returningVisitor(proxyPool);
} else {
chaoticBrowser(proxyPool);
}
}

// --- CÁC HÀM MÔ PHỎNG HÀNH VI ---
// (Không có thay đổi trong các hàm bên dưới)

function firstTimeVisitor(proxies) {
const params = getBaseParams(proxies);
group('Hành vi: Khách lần đầu', function () {
const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'Trang chủ OK': (r) => r && r.status === 200 });
if (isStatusOk) {
if (res.body) {
loadPageAssets(res, params, null);
} else {
console.error(`Phản hồi rỗng từ ${BASE_URL}`);
}
}
});
sleep(Math.random() * 4 + 3);
}

const vuCache = new Map();

function returningVisitor(proxies) {
const params = getBaseParams(proxies);
group('Hành vi: Khách quay lại', function () {
const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'Trang chủ OK': (r) => r && r.status === 200 });
if (isStatusOk) {
if (res.body) {
loadPageAssets(res, params, vuCache);
} else {
console.error(`Phản hồi rỗng từ ${BASE_URL}`);
}
}
});
sleep(Math.random() * 4 + 3);
}

const internalLinks = new Set([BASE_URL]);

function chaoticBrowser(proxies) {
const params = getBaseParams(proxies);
group('Hành vi: Người dùng đi dạo', function () {
const linksArray = Array.from(internalLinks);
const currentUrl = linksArray.length > 0 ? linksArray[Math.floor(Math.random() * linksArray.length)] : BASE_URL;
const res = http.get(currentUrl, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'Tải trang OK': (r) => r && r.status === 200 });
if (isStatusOk) {
if (res.body) {
const discoveredLinks = loadPageAssets(res, params, null);
discoveredLinks.forEach(link => internalLinks.add(link));
} else {
console.error(`Phản hồi rỗng từ ${currentUrl}`);
}
}
});
sleep(Math.random() * 5 + 4);
}

// --- CÁC HÀM HỖ TRỢ ---
// (Không có thay đổi trong các hàm bên dưới)

function getBaseParams(proxyPool) {
const params = {
headers: {
'User-Agent': USER_AGENTS[__VU % USER_AGENTS.length],
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
'Accept-Language': 'en-US,en;q=0.5',
'Accept-Encoding': 'gzip, deflate, br',
},
};

if (proxyPool && proxyPool.length > 0) {
// Mỗi VU sẽ chọn một proxy dựa trên ID của nó (__VU)
params.proxy = proxyPool[__VU % proxyPool.length];
} else {
// Trường hợp này không nên xảy ra do đã có kiểm tra trong setup()
console.warn(`[VU=${__VU}] Bể proxy rỗng. Request sẽ được gửi không qua proxy.`);
}
return params;
}

function loadPageAssets(res, params, cache) {
const discoveredLinks = new Set();
if (!res || !res.body) {
console.error(`Phản hồi không hợp lệ: ${JSON.stringify(res)}`);
return Array.from(discoveredLinks);
}

const doc = html.parse(res.body);
const assetUrls = new Set();

doc.find('link[href], script[src], img[src], video[src], audio[src], source[src]').each((_, el) => {
const url = el.attr('href') || el.attr('src');
if (url) assetUrls.add(resolveUrl(url, res.url));
});

const contentType = res.headers['Content-Type'];
const isCssResponse = contentType && contentType.includes('css');
const cssBody = doc.find('style').text() + (isCssResponse ? res.body : '');
const cssUrls = cssBody.match(/url\(['"]?([^'")]+)['"]?\)/g) || [];
cssUrls.forEach(match => {
const url = match.replace(/url\(['"]?/, '').replace(/['"]?\)/, '');
if (url && !url.startsWith('data:')) {
assetUrls.add(resolveUrl(url, res.url));
}
});

doc.find('a[href]').each((_, el) => {
const link = el.attr('href');
if (link) {
const resolvedLink = resolveUrl(link, res.url);
if (resolvedLink && resolvedLink.startsWith(BASE_URL) && !resolvedLink.match(/\.(jpg|jpeg|png|gif|css|js|pdf)$/i) && !resolvedLink.includes('#')) {
discoveredLinks.add(resolvedLink);
}
}
});

const requests = [];
assetUrls.forEach(url => {
if (url) {
const assetParams = { ...params, tags: { type: 'asset' } };
if (cache && cache.has(url)) {
assetParams.headers['If-None-Match'] = cache.get(url);
}
requests.push(['GET', url, null, assetParams]);
}
});

if (requests.length > 0) {
const responses = http.batch(requests);
if (cache) {
responses.forEach((r, i) => {
const url = requests[i][1];
if (r && r.status === 200 && r.headers['Etag']) {
cache.set(url, r.headers['Etag']);
}
if (r) {
check(r, { 'Tài nguyên cache hợp lệ (200 hoặc 304)': (res) => [200, 304].includes(res.status) });
}
});
}
}
return Array.from(discoveredLinks);
}

function resolveUrl(url, pageUrl) {
try {
return (new URL(url, pageUrl)).href;
} catch (e) {
console.warn(`URL không hợp lệ: "${url}" trên trang ${pageUrl}`);
return '';
}
}
