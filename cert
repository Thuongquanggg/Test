

// üÖæÔ∏è T√™n file: cert_updated.js
// K·ªãch b·∫£n ki·ªÉm th·ª≠ s·ª©c b·ªÅn, m√¥ ph·ªèng chu k·ª≥ ho·∫°t ƒë·ªông d√†i (h∆°n 1 gi·ªù).
// T√≠ch h·ª£p c√°c k·ªπ thu·∫≠t t·∫•n c√¥ng ƒëa chi·ªÅu v√† h√†nh vi ng∆∞·ªùi d√πng ph·ª©c t·∫°p.
// *** ƒê√É T√çCH H·ª¢P B·ªÇ PROXY T·ª∞ ƒê·ªòNG C·∫¨P NH·∫¨T ***

import http from 'k6/http';
import { check, group, sleep } from 'k6';
import { html } from 'k6/html';

// --- C·∫§U H√åNH CH√çNH ---
const BASE_URL = 'https://certapple.com';
const PROXY_API_URL = 'https://api.proxyscrape.com/v4/free-proxy-list/get?request=display_proxies&proxy_format=protocolipport&format=text';

// --- B·ªÇ D·ªÆ LI·ªÜU PROXY (S·∫º ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T ƒê·ªòNG) ---
// Kh·ªüi t·∫°o m·ªôt b·ªÉ proxy r·ªóng. H√†m setup() s·∫Ω ƒëi·ªÅn d·ªØ li·ªáu v√†o l·∫ßn ƒë·∫ßu ti√™n.
let proxyPool = ['http://0.0.0.0:1']; // Th√™m m·ªôt proxy gi·∫£ ƒë·ªÉ tr√°nh l·ªói khi API th·∫•t b·∫°i l·∫ßn ƒë·∫ßu

// --- B·ªÇ D·ªÆ LI·ªÜU USER AGENTS ---
const USER_AGENTS = [
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/115.0',
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/114.0.1823.51',
'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1',
'Mozilla/5.0 (Linux; Android 13; SM-S908U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36'
];

// --- H√ÄM L·∫§Y V√Ä C·∫¨P NH·∫¨T PROXY ---
// H√†m n√†y s·∫Ω l·∫•y proxy t·ª´ API v√† c·∫≠p nh·∫≠t v√†o bi·∫øn to√†n c·ª•c `proxyPool`
function fetchAndUpdateProxies() {
console.log('ƒêang l·∫•y danh s√°ch proxy m·ªõi...');
const res = http.get(PROXY_API_URL, { timeout: '30s' }); // TƒÉng timeout cho API
if (res.status === 200 && res.body) {
const newProxies = res.body.trim().split('\n').filter(p => p.length > 0);
if (newProxies.length > 0) {
proxyPool = newProxies;
console.log(`C·∫≠p nh·∫≠t th√†nh c√¥ng! B·ªÉ c√≥ ${proxyPool.length} proxy m·ªõi.`);
} else {
console.warn('API tr·∫£ v·ªÅ danh s√°ch proxy r·ªóng.');
}
} else {
console.error(`Kh√¥ng th·ªÉ l·∫•y proxy. Status: ${res.status}, Body: ${res.body}`);
}
}

// --- H√ÄM SETUP (CH·∫†Y 1 L·∫¶N TR∆Ø·ªöC KHI TEST B·∫ÆT ƒê·∫¶U) ---
// L·∫•y danh s√°ch proxy l·∫ßn ƒë·∫ßu ti√™n ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ s·∫µn khi test b·∫Øt ƒë·∫ßu.
export function setup() {
fetchAndUpdateProxies();
}

// --- H√ÄM C·∫¨P NH·∫¨T PROXY (CHO K·ªäCH B·∫¢N N·ªÄN) ---
// H√†m n√†y s·∫Ω ƒë∆∞·ª£c th·ª±c thi b·ªüi m·ªôt VU ri√™ng bi·ªát, c·ª© 1 ph√∫t m·ªôt l·∫ßn.
export function proxyUpdater() {
fetchAndUpdateProxies();
sleep(60); // Ch·ªù 60 gi√¢y (1 ph√∫t) tr∆∞·ªõc khi l·∫•y l·∫°i
}


// --- C·∫§U H√åNH K·ªäCH B·∫¢N TEST ---
export const options = {
insecureSkipTLSVerify: true,

scenarios: {
// K·ªäCH B·∫¢N CH√çNH: M√¥ ph·ªèng ng∆∞·ªùi d√πng truy c·∫≠p website
daily_traffic_simulation: {
executor: 'ramping-vus',
startTime: '0s',
stages: [
{ duration: '2m', target: 1000 },
{ duration: '5m', target: 1000 },
// S·ª¨A L·ªñI: 6000m (100 gi·ªù) l√† qu√° d√†i, s·ª≠a th√†nh 60m (1 gi·ªù)
{ duration: '60m', target: 1000 },
{ duration: '10m', target: 20 },
{ duration: '3m', target: 0 },
],
gracefulStop: '2m',
// Ch·ªâ ƒë·ªãnh h√†m th·ª±c thi cho k·ªãch b·∫£n n√†y l√† h√†m `default`
exec: 'default',
},
// K·ªäCH B·∫¢N N·ªÄN: Lu√¥n ch·∫°y ƒë·ªÉ c·∫≠p nh·∫≠t proxy
proxy_refresher: {
executor: 'constant-vus',
vus: 1, // Ch·ªâ c·∫ßn 1 VU ƒë·ªÉ l√†m nhi·ªám v·ª• n√†y
duration: '80m', // Ch·∫°y song song v·ªõi k·ªãch b·∫£n ch√≠nh (2+5+60+10+3 = 80m)
startTime: '0s',
// Ch·ªâ ƒë·ªãnh h√†m th·ª±c thi cho k·ªãch b·∫£n n√†y l√† `proxyUpdater`
exec: 'proxyUpdater',
gracefulStop: '10s', // Kh√¥ng c·∫ßn nhi·ªÅu th·ªùi gian ƒë·ªÉ d·ª´ng
}
},

thresholds: {
'http_req_duration{type:html}': ['p(95)<5000'],
'http_req_duration{type:asset}': ['p(95)<3000'],
'http_req_failed': ['rate<0.30'],
'checks': ['rate>0.70'],
},

discardResponseBodies: false,
};

// --- ƒêI·ªÇM V√ÄO CH√çNH C·ª¶A NG∆Ø·ªúI D√ôNG ·∫¢O ---
// H√†m n√†y ƒë∆∞·ª£c th·ª±c thi b·ªüi k·ªãch b·∫£n `daily_traffic_simulation`
export default function () {
const random = Math.random();
if (random < 0.2) {
firstTimeVisitor();
} else if (random < 0.4) {
returningVisitor();
} else {
chaoticBrowser();
}
}

// --- C√ÅC H√ÄM M√î PH·ªéNG H√ÄNH VI C·ª§ TH·ªÇ (KH√îNG THAY ƒê·ªîI) ---

function firstTimeVisitor() {
const params = getBaseParams();
group('H√†nh vi: Kh√°ch l·∫ßn ƒë·∫ßu', function () {
const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'Trang ch·ªß OK': (r) => r && r.status === 200 });
if (isStatusOk) {
loadPageAssets(res, params, null);
}
});
sleep(Math.random() * 4 + 3);
}

const vuCache = new Map();
function returningVisitor() {
const params = getBaseParams();
group('H√†nh vi: Kh√°ch quay l·∫°i', function () {
const res = http.get(BASE_URL, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'Trang ch·ªß OK': (r) => r && r.status === 200 });
if (isStatusOk) {
loadPageAssets(res, params, vuCache);
}
});
sleep(Math.random() * 4 + 3);
}

const internalLinks = new Set([BASE_URL]);
function chaoticBrowser() {
const params = getBaseParams();
group('H√†nh vi: Ng∆∞·ªùi d√πng ƒëi d·∫°o', function () {
const linksArray = Array.from(internalLinks);
const currentUrl = linksArray[Math.floor(Math.random() * linksArray.length)];
const res = http.get(currentUrl, { ...params, tags: { type: 'html' } });
const isStatusOk = check(res, { 'T·∫£i trang OK': (r) => r && r.status === 200 });
if (isStatusOk) {
const discoveredLinks = loadPageAssets(res, params, null);
discoveredLinks.forEach(link => internalLinks.add(link));
}
});
sleep(Math.random() * 5 + 4);
}

// --- C√ÅC H√ÄM H·ªñ TR·ª¢ ---

// *** H√ÄM ƒê√É ƒê∆Ø·ª¢C S·ª¨A ƒê·ªîI ƒê·ªÇ D√ôNG BI·∫æN PROXY ƒê·ªòNG ***
function getBaseParams() {
// Th√™m ki·ªÉm tra ƒë·ªÉ ƒë·∫£m b·∫£o b·ªÉ proxy kh√¥ng r·ªóng
if (proxyPool.length === 0) {
// N·∫øu kh√¥ng c√≥ proxy, g·ª≠i request tr·ª±c ti·∫øp v√† log m·ªôt c·∫£nh b√°o
console.warn('B·ªÉ proxy ƒëang r·ªóng! Request s·∫Ω ƒë∆∞·ª£c g·ª≠i kh√¥ng qua proxy.');
return {
headers: {
'User-Agent': USER_AGENTS[__VU % USER_AGENTS.length],
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
'Accept-Language': 'en-US,en;q=0.5',
'Accept-Encoding': 'gzip, deflate, br',
},
};
}

// S·ª≠ d·ª•ng bi·∫øn `proxyPool` ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªông
const proxyUrl = proxyPool[__VU % proxyPool.length];

return {
proxy: proxyUrl,
headers: {
'User-Agent': USER_AGENTS[__VU % USER_AGENTS.length],
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
'Accept-Language': 'en-US,en;q=0.5',
'Accept-Encoding': 'gzip, deflate, br',
},
};
}

// H√†m loadPageAssets v√† resolveUrl kh√¥ng thay ƒë·ªïi
function loadPageAssets(res, params, cache) {
const discoveredLinks = new Set();

if (!res || !res.body) {
return Array.from(discoveredLinks);
}

const doc = html.parse(res.body);
const assetUrls = new Set();

doc.find('link[href], script[src], img[src], video[src], audio[src], source[src]').each((_, el) => {
const url = el.attr('href') || el.attr('src');
if (url) assetUrls.add(resolveUrl(url, res.url));
});

const contentType = res.headers['Content-Type'];
const isCssResponse = contentType && contentType.includes('css');
const cssBody = doc.find('style').text() + (isCssResponse ? res.body : '');

const cssUrls = cssBody.match(/url\(['"]?([^'")]+)['"]?\)/g) || [];
cssUrls.forEach(match => {
const url = match.replace(/url\(['"]?/, '').replace(/['"]?\)/, '');
if (url && !url.startsWith('data:')) {
assetUrls.add(resolveUrl(url, res.url));
}
});

doc.find('a[href]').each((_, el) => {
const link = el.attr('href');
if(link) {
const resolvedLink = resolveUrl(link, res.url);
if (resolvedLink && resolvedLink.startsWith(BASE_URL) && !resolvedLink.match(/\.(jpg|jpeg|png|gif|css|js|pdf)$/i) && !resolvedLink.includes('#')) {
discoveredLinks.add(resolvedLink);
}
}
});

const requests = [];
assetUrls.forEach(url => {
if(url) {
const assetParams = { ...params, tags: { type: 'asset' } };
if (cache && cache.has(url)) {
assetParams.headers['If-None-Match'] = cache.get(url);
}
requests.push(['GET', url, null, assetParams]);
}
});

if (requests.length > 0) {
const responses = http.batch(requests);
if (cache) {
responses.forEach((r, i) => {
const url = requests[i][1];
if (r && r.status === 200 && r.headers['Etag']) {
cache.set(url, r.headers['Etag']);
}
if (r) {
check(r, { 'T√†i nguy√™n cache h·ª£p l·ªá (200 ho·∫∑c 304)': (res) => [200, 304].includes(res.status) });
}
});
}
}
return Array.from(discoveredLinks);
}

function resolveUrl(url, pageUrl) {
try {
return (new URL(url, pageUrl)).href;
} catch (e) {
return '';
}
}
